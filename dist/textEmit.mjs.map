{
  "version": 3,
  "sources": ["../src/textEmit/index.mjs"],
  "sourcesContent": ["// Copyright 2024 (C) Lightingale Community\n// Licensed under GNU LGPL 3.0\n\n// Takes a stream, and emit decoded text\n\n// TextEmit is now deprecated, as it has the potential to overwhelm the stream consumer.\n\n\"use strict\";\n\nconst encodings = [\"utf-8\", \"utf-16\", \"utf-16be\"];\n\n/*\nontext: When a line of text is available, returns the decoded string\nonfail: When a line of text is available but decoding failed, returns the raw bytes\nonchunk: When a chunk is received, returns the raw bytes\nonraw: When a line of text is available, returns the raw bytes\nonclose\n*/\n\nlet TextEmitter = class extends EventTarget {\n\tstatic SPLIT_UTF_8 = 0;\n\tstatic SPLIT_UTF_16_LE = 1;\n\tstatic SPLIT_UTF_16_BE = 2;\n\t#stream;\n\t#decoder;\n\tconstructor(stream, splitMode = 0) {\n\t\tsuper();\n\t\tif (splitMode?.constructor != Number ||\n\t\t\tsplitMode < 0 ||\n\t\t\tsplitMode >= encodings.length) {\n\t\t\tthrow(new TypeError(\"Invalid split mode\"));\n\t\t};\n\t\tif (splitMode) {\n\t\t\tthrow(new Error(\"UTF-16LE/BE currently not implemented\"));\n\t\t};\n\t\tif (!stream || stream?.constructor != ReadableStream) {\n\t\t\tthrow(new TypeError(\"Not a readable stream\"));\n\t\t};\n\t\tthis.#stream = stream;\n\t\tlet reader = stream.getReader();\n\t\tthis.#decoder = new TextDecoder(encodings[splitMode], {fatal: true});\n\t\tlet streamAlive = true, notClosed = true;\n\t\tlet buffer;\n\t\t(async () => {\n\t\t\treader.closed.then(() => {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"raw\", {\n\t\t\t\t\t\t\"data\": buffer\n\t\t\t\t\t}));\n\t\t\t\t\tbuffer = undefined;\n\t\t\t\t};\n\t\t\t\tthis.dispatchEvent(new Event(\"close\"));\n\t\t\t\tnotClosed = false;\n\t\t\t}).catch((err) => {\n\t\t\t\tif (buffer) {\n\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"raw\", {\n\t\t\t\t\t\t\"data\": buffer\n\t\t\t\t\t}));\n\t\t\t\t\tbuffer = undefined;\n\t\t\t\t};\n\t\t\t\tthis.dispatchEvent(new ErrorEvent(\"error\", {\n\t\t\t\t\tmessage: err.message,\n\t\t\t\t\terror: err\n\t\t\t\t}));\n\t\t\t\tthis.dispatchEvent(new Event(\"close\"));\n\t\t\t\tnotClosed = false;\n\t\t\t});\n\t\t\twhile (streamAlive && notClosed) {\n\t\t\t\ttry {\n\t\t\t\t\tlet chunk = await reader.read();\n\t\t\t\t\tstreamAlive = !chunk.done;\n\t\t\t\t\tif (streamAlive) {\n\t\t\t\t\t\tlet byteArray = chunk.value;\n\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"chunk\", {\n\t\t\t\t\t\t\t\"data\": byteArray\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (byteArray.constructor != Uint8Array &&\n\t\t\t\t\t\t\tbyteArray.constructor != Uint8ClampedArray) {\n\t\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"fail\", {\n\t\t\t\t\t\t\t\t\"data\": byteArray\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Splitter!\n\t\t\t\t\t\t\tlet startIdx = 0;\n\t\t\t\t\t\t\tlet endIdx = 0;\n\t\t\t\t\t\t\tlet lastChar = 0;\n\t\t\t\t\t\t\tlet isBroken = false;\n\t\t\t\t\t\t\tfor (let i = 0; i < byteArray.length; i ++) {\n\t\t\t\t\t\t\t\tswitch (byteArray[i]) {\n\t\t\t\t\t\t\t\t\tcase 10: {\n\t\t\t\t\t\t\t\t\t\tif (lastChar == 13) {\n\t\t\t\t\t\t\t\t\t\t\tstartIdx ++;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tisBroken = true;\n\t\t\t\t\t\t\t\t\t\t\tendIdx = i;\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tcase 13: {\n\t\t\t\t\t\t\t\t\t\tisBroken = true;\n\t\t\t\t\t\t\t\t\t\tendIdx = i;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdefault: {\n\t\t\t\t\t\t\t\t\t\tisBroken = false;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (isBroken) {\n\t\t\t\t\t\t\t\t\tlet sliceBuffer = byteArray.subarray(startIdx, endIdx);\n\t\t\t\t\t\t\t\t\tlet commitBuffer = sliceBuffer;\n\t\t\t\t\t\t\t\t\tif (buffer) {\n\t\t\t\t\t\t\t\t\t\tcommitBuffer = new Uint8Array(buffer.length + sliceBuffer.length);\n\t\t\t\t\t\t\t\t\t\tcommitBuffer.set(buffer);\n\t\t\t\t\t\t\t\t\t\tcommitBuffer.set(sliceBuffer, buffer.length);\n\t\t\t\t\t\t\t\t\t\tbuffer = undefined;\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"raw\", {\n\t\t\t\t\t\t\t\t\t\t\"data\": commitBuffer\n\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tlet text = this.#decoder.decode(commitBuffer);\n\t\t\t\t\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"text\", {\n\t\t\t\t\t\t\t\t\t\t\t\"data\": text\n\t\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"fail\", {\n\t\t\t\t\t\t\t\t\t\t\t\"data\": commitBuffer\n\t\t\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tstartIdx = i + 1;\n\t\t\t\t\t\t\t\t\tisBroken = false;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tlastChar = byteArray[i];\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (!isBroken) {\n\t\t\t\t\t\t\t\t// Commit unfinished text to buffer\n\t\t\t\t\t\t\t\tif (buffer) {\n\t\t\t\t\t\t\t\t\tlet sliceBuffer = byteArray.subarray(startIdx);\n\t\t\t\t\t\t\t\t\tlet commitBuffer = new Uint8Array(buffer.length + sliceBuffer.length);\n\t\t\t\t\t\t\t\t\tcommitBuffer.set(buffer);\n\t\t\t\t\t\t\t\t\tcommitBuffer.set(sliceBuffer, buffer.length);\n\t\t\t\t\t\t\t\t\tbuffer = commitBuffer;\n\t\t\t\t\t\t\t\t} else if (startIdx < byteArray.length) {\n\t\t\t\t\t\t\t\t\tbuffer = byteArray.subarray(startIdx);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (buffer) {\n\t\t\t\t\t\t\t// Empty the buffer\n\t\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"raw\", {\n\t\t\t\t\t\t\t\t\"data\": buffer\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\tbuffer = undefined;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.dispatchEvent(new Event(\"close\"));\n\t\t\t\t\t};\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (buffer) {\n\t\t\t\t\t\t// Empty the buffer\n\t\t\t\t\t\tthis.dispatchEvent(new MessageEvent(\"raw\", {\n\t\t\t\t\t\t\t\"data\": buffer\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tbuffer = undefined;\n\t\t\t\t\t};\n\t\t\t\t\tthis.dispatchEvent(new ErrorEvent(\"error\", {\n\t\t\t\t\t\tmessage: err.message,\n\t\t\t\t\t\terror: err\n\t\t\t\t\t}));\n\t\t\t\t\tthis.dispatchEvent(new Event(\"close\"));\n\t\t\t\t};\n\t\t\t};\n\t\t})();\n\t};\n};\n\nexport default TextEmitter;\n"],
  "mappings": "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",
  "names": ["encodings", "TextEmitter", "#stream", "#decoder", "stream", "splitMode", "reader", "streamAlive", "notClosed", "buffer", "err", "chunk", "byteArray", "startIdx", "endIdx", "lastChar", "isBroken", "i", "sliceBuffer", "commitBuffer", "text", "textEmit_default"]
}
