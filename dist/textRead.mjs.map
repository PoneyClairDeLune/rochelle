{
  "version": 3,
  "sources": ["../src/textRead/index.mjs"],
  "sourcesContent": ["// Copyright 2024 (C) Lightingale Community\n// Licensed under GNU LGPL 3.0\n\n// Takes a stream, and read decoded text by line on demand\n\n\"use strict\";\n\nconst encodings = [\"utf-8\", \"utf-16\", \"utf-16be\"];\n\nlet commitData = (controller, data) => {\n\tcontroller.unsent = false;\n\tcontroller.enqueue(data);\n};\n\nlet TextReader = class {\n\tstatic SPLIT_UTF_8 = 0;\n\tstatic SPLIT_UTF_16_LE = 1;\n\tstatic SPLIT_UTF_16_BE = 2;\n\tstatic lineRaw(stream, splitMode = 0) {\n\t\tif (splitMode?.constructor != Number ||\n\t\t\tsplitMode < 0 ||\n\t\t\tsplitMode >= encodings.length) {\n\t\t\tthrow(new TypeError(\"Invalid split mode\"));\n\t\t};\n\t\tif (splitMode) {\n\t\t\tthrow(new Error(\"UTF-16LE/BE currently not implemented\"));\n\t\t};\n\t\tif (!stream || stream?.constructor != ReadableStream) {\n\t\t\tthrow(new TypeError(\"Not a readable stream\"));\n\t\t};\n\t\tlet reader = stream.getReader();\n\t\tlet chunk, finished = false;\n\t\tlet bufferBuilder = [], ptr = 0, lastPtr = 0, lastUnit = 0;\n\t\tlet sink = new ReadableStream({\n\t\t\t\"pull\": async (controller) => {\n\t\t\t\tcontroller.unsent = true;\n\t\t\t\twhile (controller.unsent) {\n\t\t\t\t\tif (!chunk || ptr >= chunk.length) {\n\t\t\t\t\t\t// Commit unfinished buffer\n\t\t\t\t\t\tif (ptr > lastPtr) {\n\t\t\t\t\t\t\tbufferBuilder.push(chunk.subarray(lastPtr));\n\t\t\t\t\t\t\tlastPtr = 0;\n\t\t\t\t\t\t\t//console.debug(`Read a new chunk.`);\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// Read a new chunk\n\t\t\t\t\t\tlet {value, done} = await reader.read();\n\t\t\t\t\t\tchunk = value;\n\t\t\t\t\t\tfinished = done;\n\t\t\t\t\t\t// Reset pointer\n\t\t\t\t\t\tptr = 0;\n\t\t\t\t\t};\n\t\t\t\t\tif (chunk) {\n\t\t\t\t\t\t// Continue the read operation\n\t\t\t\t\t\t////console.debug(`Read byte at chunk pointer ${ptr}.`);\n\t\t\t\t\t\tlet e = chunk[ptr];\n\t\t\t\t\t\tlet commitNow = false;\n\t\t\t\t\t\tswitch (e) {\n\t\t\t\t\t\t\tcase 10: {\n\t\t\t\t\t\t\t\tif (lastUnit == 13) {\n\t\t\t\t\t\t\t\t\tlastPtr ++;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcommitNow = true;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcase 13: {\n\t\t\t\t\t\t\t\tcommitNow = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (commitNow) {\n\t\t\t\t\t\t\tif (bufferBuilder.length) {\n\t\t\t\t\t\t\t\t//console.debug(`Building a multi-part buffer. ${ptr}`);\n\t\t\t\t\t\t\t\t// Add buffer\n\t\t\t\t\t\t\t\tbufferBuilder.push(chunk.subarray(lastPtr, ptr));\n\t\t\t\t\t\t\t\t// Calculate buffer size\n\t\t\t\t\t\t\t\tlet mergeLen = 0;\n\t\t\t\t\t\t\t\tfor (let i = 0; i < bufferBuilder.length; i ++) {\n\t\t\t\t\t\t\t\t\tmergeLen += bufferBuilder[i].length;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// Merge buffer\n\t\t\t\t\t\t\t\tlet mergedBuffer = new Uint8Array(mergeLen);\n\t\t\t\t\t\t\t\tlet mergedPtr = 0;\n\t\t\t\t\t\t\t\tfor (let i = 0; i < bufferBuilder.length; i ++) {\n\t\t\t\t\t\t\t\t\tmergedBuffer.set(bufferBuilder[i], mergedPtr);\n\t\t\t\t\t\t\t\t\tmergedPtr += bufferBuilder[i].length;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t// Commit buffer\n\t\t\t\t\t\t\t\tcommitData(controller, mergedBuffer);\n\t\t\t\t\t\t\t\t// Clear buffer\n\t\t\t\t\t\t\t\tbufferBuilder = [];\n\t\t\t\t\t\t\t\t//console.debug(`Multi-part buffer write finished. ${ptr}`);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// Just commit the current segment\n\t\t\t\t\t\t\t\tcommitData(controller, chunk.subarray(lastPtr, ptr));\n\t\t\t\t\t\t\t\t//console.debug(`Single buffer write finished. ${ptr}`);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlastPtr = ptr + 1;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tlastUnit = e;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//console.debug(`No reading available. ${ptr}`);\n\t\t\t\t\t};\n\t\t\t\t\tif (finished) {\n\t\t\t\t\t\t//console.debug(`Stream finished.`);\n\t\t\t\t\t\t// Detect remaining buffer\n\t\t\t\t\t\tif (lastPtr != ptr) {\n\t\t\t\t\t\t\tbufferBuilder.push(chunk.subarray(lastPtr, ptr));\n\t\t\t\t\t\t};\n\t\t\t\t\t\t// Commit all remaining buffer\n\t\t\t\t\t\tif (bufferBuilder.length) {\n\t\t\t\t\t\t\t//console.debug(`Building a multi-part buffer.`);\n\t\t\t\t\t\t\t// Calculate buffer size\n\t\t\t\t\t\t\tlet mergeLen = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < bufferBuilder.length; i ++) {\n\t\t\t\t\t\t\t\tmergeLen += bufferBuilder[i].length;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// Merge buffer\n\t\t\t\t\t\t\tlet mergedBuffer = new Uint8Array(mergeLen);\n\t\t\t\t\t\t\tlet mergedPtr = 0;\n\t\t\t\t\t\t\tfor (let i = 0; i < bufferBuilder.length; i ++) {\n\t\t\t\t\t\t\t\tmergedBuffer.set(bufferBuilder[i], mergedPtr);\n\t\t\t\t\t\t\t\tmergedPtr += bufferBuilder[i].length;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// Commit buffer\n\t\t\t\t\t\t\tcommitData(controller, mergedBuffer);\n\t\t\t\t\t\t\t//console.debug(`Multi-part buffer write finished.`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Close the stream\n\t\t\t\t\t\tcontroller.unsent = false;\n\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t};\n\t\t\t\t\tptr ++;\n\t\t\t\t};\n\t\t\t}\n\t\t}, new ByteLengthQueuingStrategy({\"highWaterMark\": 256}));\n\t\treturn sink;\n\t};\n\tstatic line(stream, splitMode = 0, label) {\n\t\tlet rawStream = this.lineRaw(stream, splitMode).getReader();\n\t\tlet decoder = new TextDecoder(label || encodings[splitMode]);\n\t\treturn new ReadableStream({\n\t\t\t\"pull\": async (controller) => {\n\t\t\t\tlet {value, done} = await rawStream.read();\n\t\t\t\tif (value) {\n\t\t\t\t\tcontroller.enqueue(decoder.decode(value));\n\t\t\t\t};\n\t\t\t\tif (done) {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t};\n};\n\nexport default TextReader;\n"],
  "mappings": "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",
  "names": ["encodings", "commitData", "controller", "data", "TextReader", "stream", "splitMode", "reader", "chunk", "finished", "bufferBuilder", "ptr", "lastPtr", "lastUnit", "value", "done", "e", "commitNow", "mergeLen", "i", "mergedBuffer", "mergedPtr", "label", "rawStream", "decoder", "textRead_default"]
}
